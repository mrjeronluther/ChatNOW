<!doctype html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
      <title>IntraTALKS</title>

      <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
      <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet" />
      <link
         href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono&display=swap"
         rel="stylesheet"
      />
      <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>

      <style>
         /* --- COLOR SCHEME & VARIABLES --- */
         :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --primary: #2f81f7;
            --me-bg: #1f6feb;
            --me-text: #fff;
            --text: #c9d1d9;
            --muted: #8b949e;
            --danger: #da3633;
            --warning: #d29922;
            --tick-seen: #4fc3f7;
            --online: #3fb950;
         }

         /* --- GLOBAL STYLES --- */
         * {
            box-sizing: border-box;
            outline: none;
            -webkit-tap-highlight-color: transparent;
         }
         body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: "Inter", sans-serif;
            height: 100dvh;
            overflow: hidden;
         }
         [v-cloak] {
            display: none;
         }
         .msg-container::-webkit-scrollbar,
         textarea::-webkit-scrollbar,
         aside::-webkit-scrollbar {
            display: none;
         }
         .msg-container,
         textarea,
         aside {
            -ms-overflow-style: none;
            scrollbar-width: none;
         }

         /* --- MODALS & LOADERS --- */
         .global-loader {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            backdrop-filter: blur(6px);
         }
         .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 90000;
            padding: 20px;
         }
         .modal-box {
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 24px;
            border-radius: 12px;
            width: 100%;
            max-width: 450px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
         }
         .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
         }
         @keyframes spin {
            to {
               transform: rotate(360deg);
            }
         }

         /* --- INPUTS & BUTTONS --- */
         input {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #010409;
            color: white;
         }
         .btn {
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            border: none;
            font-size: 13px;
            transition: 0.2s;
         }
         .btn-primary {
            background: #238636;
            color: white;
         }
         .btn-cancel {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
         }
         .btn-danger {
            background: var(--danger);
            color: white;
         }

         /* --- MAIN CHAT LAYOUT --- */

         .chat-view {
            display: flex;
            height: 100dvh;
            animation: fadeInApp 0.3s ease-out; /* Makes the transition smooth */
         }

         @keyframes fadeInApp {
            from {
               opacity: 0;
            }
            to {
               opacity: 1;
            }
         }
         aside {
            width: 280px;
            background: #010409;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: 0.3s;
            z-index: 2500;
         }
         main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg);
            position: relative;
            overflow: hidden;
         }
         header {
            height: 60px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 15px;
         }
         /* This ensures the user doesn't see the messages jumping from top to bottom */
         .msg-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.4s ease-in;
         }

         .msg-container.loaded {
            opacity: 1; /* Revealed only after bootstrapApp sets isInitialLoad to false */
         }

         /* --- TYPING & STATUS --- */
         .status-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
         }
         .dot-online {
            background: var(--online);
            box-shadow: 0 0 6px var(--online);
         }
         .dot-offline {
            background: #444;
         }
         .typing-indicator {
            align-self: flex-start;
            margin: 4px 0 15px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--muted);
         }
         .typing-bubble {
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 12px;
            display: flex;
            gap: 3px;
         }
         .dot {
            width: 4px;
            height: 4px;
            background: var(--muted);
            border-radius: 50%;
            animation: bounce 1.4s infinite;
         }
         @keyframes bounce {
            0%,
            80%,
            100% {
               transform: translateY(0);
            }
            40% {
               transform: translateY(-5px);
            }
         }

         /* --- MESSAGE BUBBLES --- */
         .msg {
            display: flex;
            flex-direction: column;
            max-width: 85%;
            position: relative;
            transition: transform 0.15s ease-out;
            user-select: none;
         }
         .msg.me {
            align-self: flex-end;
            align-items: flex-end;
         }
         .msg.other {
            align-self: flex-start;
            align-items: flex-start;
         }
         .msg-row {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            position: relative;
         }
         .msg.me .msg-row {
            flex-direction: row-reverse;
         }
         .bubble {
            padding: 10px 14px;
            border-radius: 14px;
            background: var(--panel);
            border: 1px solid var(--border);
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
            position: relative;
            z-index: 2;
         }
         .msg.me .bubble {
            background: var(--me-bg);
            color: var(--me-text);
            border: none;
            border-bottom-right-radius: 2px;
         }
         .msg.other .bubble {
            border-bottom-left-radius: 2px;
         }

         /* --- DROPDOWN MENU --- */
         .msg-menu-wrap {
            position: relative;
            transition: opacity 0.2s;
            opacity: 0;
         }
         @media (min-width: 769px) {
            .msg:hover .msg-menu-wrap {
               opacity: 1;
            }
         }
         @media (max-width: 768px) {
            .msg-menu-wrap {
               opacity: 1;
            }
         }
         .dots-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--muted);
         }
         .menu-dropdown {
            position: fixed;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            min-width: 160px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            overflow: hidden;
         }
         .menu-item {
            height: 42px;
            padding: 0 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            cursor: pointer;
            transition: 0.2s;
         }
         .menu-item:hover {
            background: var(--border);
            color: var(--primary);
         }
         .menu-item.danger:hover {
            color: var(--danger);
         }
         .menu-backdrop {
            position: fixed;
            inset: 0;
            z-index: 9998;
         }

         /* --- BOTTOM BAR & UI --- */
         footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            background: var(--bg);
         }
         .input-pill {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #010409;
            border: 1px solid var(--border);
            border-radius: 28px;
            padding: 4px 16px;
         }
         textarea {
            flex: 1;
            min-height: 24px;
            max-height: 150px;
            background: transparent;
            border: none;
            padding: 10px 0;
            color: white;
            resize: none;
            font-size: 14px;
         }
         .scroll-bottom-btn {
            position: absolute;
            right: 20px;
            bottom: 100px;
            width: 42px;
            height: 42px;
            background: var(--panel);
            border: 1px solid var(--primary);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: 0.2s;
         }
         .red-dot {
            position: absolute;
            top: 0;
            right: 0;
            width: 12px;
            height: 12px;
            background: var(--danger);
            border: 2px solid var(--panel);
            border-radius: 50%;
         }
         .date-pill {
            align-self: center;
            background: var(--panel);
            border: 1px solid var(--border);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 10px;
            color: var(--muted);
            margin: 15px 0;
         }
         .swipe-icon {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            color: var(--primary);
            opacity: 0;
            transition: 0.2s;
         }
         .watermark {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            opacity: 0.2;
            pointer-events: none;
         }

         /* --- MOBILE SIDEBAR --- */
         /* 1. Define default hidden state FIRST */
         .hamburger-icon {
            display: none;
            color: var(--text); /* Ensures the icon isn't black on a black background */
            font-size: 20px;
            cursor: pointer;
         }

         /* 2. Define mobile override SECOND */
         @media (max-width: 768px) {
            aside {
               position: fixed;
               left: -280px;
               height: 100%;
            }
            aside.open {
               left: 0;
            }
            .sidebar-overlay {
               position: fixed;
               inset: 0;
               background: rgba(0, 0, 0, 0.7);
               z-index: 2400;
            }
            .hamburger-icon {
               display: block; /* This will now correctly override the 'none' above */
            }
         }
         /* Add this to your style section for a smoother entrance */
         @keyframes pulse {
            0% {
               opacity: 0.5;
            }
            50% {
               opacity: 1;
            }
            100% {
               opacity: 0.5;
            }
         }

         .chat-view {
            animation: fadeIn 0.4s ease-out;
         }

         @keyframes fadeIn {
            from {
               opacity: 0;
               transform: scale(0.98);
            }
            to {
               opacity: 1;
               transform: scale(1);
            }
         }

         /* AI Summary Specialized Styles */
         .summary-content {
            text-align: left;
            max-height: 60vh;
            overflow-y: auto;
            padding: 10px 5px;
            line-height: 1.6;
            font-size: 14px;
         }

         .summary-section {
            background: rgba(47, 129, 247, 0.1);
            border-left: 3px solid var(--primary);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
         }

         /* Styling the Summary Modal Content */
         .summary-list {
            margin: 0;
            padding-left: 15px;
            list-style-type: none; /* We hide default bullets to use custom ones */
         }

         .summary-list li {
            position: relative;
            margin-bottom: 12px; /* Space between points */
            line-height: 1.6;
            color: var(--text);
            font-size: 14px;
            padding-left: 10px;
         }

         /* Custom Blue Dot for each bullet point */
         .summary-list li::before {
            content: "â€¢";
            color: var(--primary);
            font-weight: bold;
            position: absolute;
            left: -15px;
            font-size: 20px;
            top: -2px;
         }

         /* Ensure the modal content is left-aligned for reading */
         .summary-container {
            text-align: left;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
         }

         .summary-badge {
            display: inline-block;
            padding: 2px 8px;
            background: var(--primary);
            color: white;
            font-size: 10px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 10px;
         }

         /* Custom Scrollbar for Summary */
         .summary-content::-webkit-scrollbar {
            display: block;
            width: 4px;
         }
         .summary-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 10px;
         }
      </style>
   </head>
   <body @click="activeMenuId = null">
      <div id="app" v-cloak>
         <!-- LOADING OVERLAY -->
         <div v-if="loading" class="global-loader">
            <div class="spinner"></div>
            <div style="margin-top: 15px; font-size: 11px; color: var(--primary)">Loading...</div>
         </div>

         <!-- DYNAMIC MODALS -->
         <!-- DYNAMIC MODALS -->
         <div v-if="modal.show" class="modal-overlay">
            <!-- Dynamic max-width: wider for summaries, narrow for alerts -->
            <div
               class="modal-box"
               :style="{ textAlign: modal.isHtml ? 'left' : 'center', maxWidth: modal.isHtml ? '600px' : '450px' }"
            >
               <h3 :style="{color: modal.type==='danger'?'var(--danger)':'var(--primary)', marginBottom: '15px'}">
                  {{ modal.title }}
               </h3>

               <!-- Use v-html for AI summaries, standard interpolation for alerts -->
               <div v-if="modal.isHtml" v-html="modal.message" class="summary-content"></div>
               <!-- Use v-html so the browser renders the tags, not just the text -->
               <div
                  v-html="modal.message"
                  style="margin-bottom: 24px; opacity: 0.8; font-size: 14px; text-align: left"
               ></div>

               <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px">
                  <button v-if="modal.isConfirm" class="btn btn-cancel" @click="closeModal(false)">Cancel</button>
                  <button
                     class="btn"
                     :class="modal.type==='danger'?'btn-danger':'btn-primary'"
                     @click="closeModal(true)"
                  >
                     {{ modal.confirmText || 'OK' }}
                  </button>
               </div>
            </div>
         </div>

         <!-- PROFILE SETTINGS -->
         <div v-if="showProfile" class="modal-overlay">
            <div class="modal-box">
               <h3>Account Settings</h3>
               <input v-model="profileForm.username" placeholder="Username" />
               <input v-model="profileForm.oldPass" type="password" placeholder="Current Password" />
               <input v-model="profileForm.newPass" type="password" placeholder="New Password" />
               <button class="btn btn-primary" style="width: 100%" @click="updateProfile">Save Changes</button>
               <button class="btn btn-cancel" style="width: 100%; margin-top: 8px" @click="showProfile=false">
                  Cancel
               </button>
            </div>
         </div>

         <!-- ADMIN CONSOLE -->
         <div v-if="showAdmin" class="modal-overlay">
            <div class="modal-box" style="max-width: 500px">
               <h3>User Management</h3>
               <div
                  v-for="u in adminUsers"
                  :key="u.email"
                  style="
                     border-bottom: 1px solid var(--border);
                     padding: 12px 0;
                     display: flex;
                     justify-content: space-between;
                     align-items: center;
                  "
               >
                  <div>
                     <span style="font-size: 14px; font-weight: 600">{{ u.username }}</span>
                     <span style="font-size: 10px; display: block; opacity: 0.6">{{ u.email }} ({{ u.status }})</span>
                  </div>
                  <div style="display: flex; gap: 6px">
                     <template v-if="u.status === 'pending'">
                        <button
                           class="btn btn-primary"
                           style="padding: 4px 8px; font-size: 10px"
                           @click="adminAction(u.email, 'approve')"
                        >
                           Accept
                        </button>
                        <button
                           class="btn btn-danger"
                           style="padding: 4px 8px; font-size: 10px"
                           @click="adminAction(u.email, 'reject')"
                        >
                           Reject
                        </button>
                     </template>
                     <template v-else-if="u.status === 'active' && u.email !== user.email">
                        <button
                           class="btn btn-danger"
                           style="padding: 4px 8px; font-size: 10px"
                           @click="adminAction(u.email, 'ban')"
                        >
                           Remove
                        </button>
                     </template>
                  </div>
               </div>
               <button class="btn btn-cancel" style="width: 100%; margin-top: 15px" @click="showAdmin=false">
                  Close
               </button>
            </div>
         </div>

         <!-- AUTHENTICATION & BOOTSTRAPPING VIEW -->
         <div
            v-if="!user || isBootstrapping"
            style="display: flex; justify-content: center; align-items: center; height: 100dvh"
         >
            <div class="modal-box" style="text-align: center">
               <h2 style="margin-bottom: 30px">
                  <span style="color: grey">Intra</span>
                  <span style="color: lightblue">TALKS</span>
               </h2>

               <!-- SHOW ONLY ON REFRESH: Full-page restoring message -->
               <div v-if="isRestoringSession">
                  <div class="spinner" style="margin: 0 auto 20px auto"></div>
                  <p style="font-size: 14px; color: var(--text); font-weight: 500">Restoring Session</p>
                  <p style="margin-top: 10px; font-size: 11px; color: var(--muted); animation: pulse 1.5s infinite">
                     Fetching your latest messages...
                  </p>
               </div>

               <!-- SHOW ON NORMAL LOGIN: Keep the form visible but keep button spinning -->
               <div v-else>
                  <div v-if="viewMode === 'login'">
                     <input 
                        v-model="form.email" 
                        type="email" 
                        autocomplete="email" 
                        placeholder="Email" 
                        :disabled="isLoggingIn" 
                      />
                     <input v-model="form.pass" type="password" placeholder="Password" :disabled="isLoggingIn" />

                     <button class="btn btn-primary" style="width: 100%" :disabled="isLoggingIn" @click="login">
                        <template v-if="isLoggingIn">
                           <i class="fas fa-spinner fa-spin" style="margin-right: 8px"></i>
                           <!-- This shows while bootstrapApp is running after a fresh login -->
                           <span v-if="isBootstrapping">Syncing Chat...</span>
                           <span v-else>Signing In...</span>
                        </template>
                        <template v-else>Sign In</template>
                     </button>

                     <div
                        v-if="!isLoggingIn"
                        style="
                           margin-top: 25px;
                           font-size: 12px;
                           color: var(--muted);
                           display: flex;
                           justify-content: center;
                           gap: 15px;
                        "
                     >
                        <span @click="viewMode='register'" style="cursor: pointer; color: var(--primary)"
                           >Creat Account</span
                        >
                        <span style="opacity: 0.3">|</span>
                        <span @click="viewMode='forgot'" style="cursor: pointer">Forgot Password?</span>
                     </div>
                  </div>

                  <!-- REGISTER FORM -->
                  <div v-else-if="viewMode === 'register'">
                     <input v-model="form.username" placeholder="Username" />
                     <input v-model="form.email" placeholder="Email" />
                     <input v-model="form.pass" type="password" placeholder="Password" />

                     <button class="btn btn-primary" style="width: 100%" @click="register">Create Account</button>

                     <div
                        @click="viewMode='login'"
                        style="margin-top: 20px; cursor: pointer; font-size: 12px; color: var(--muted)"
                     >
                        Back to Login
                     </div>
                  </div>

                  <!-- FORGOT PASSWORD FORM -->
                  <div v-else-if="viewMode === 'forgot'">
                     <p style="font-size: 13px; color: var(--muted); margin-bottom: 20px">
                        A temporary password will be sent to your email.
                     </p>
                     <input v-model="form.email" placeholder="Email Address" />

                     <button class="btn btn-primary" style="width: 100%" @click="sendForgot">Request Password</button>

                     <div
                        @click="viewMode='login'"
                        style="margin-top: 20px; cursor: pointer; font-size: 12px; color: var(--muted)"
                     >
                        Back to Login
                     </div>
                  </div>
               </div>
            </div>
         </div>

         <!-- CHAT VIEW -->
         <div v-else-if="user && !isBootstrapping" class="chat-view">
            <div v-if="showSidebar" class="sidebar-overlay" @click="showSidebar = false"></div>
            <aside :class="{ open: showSidebar }">
               <div
                  style="
                     padding: 20px;
                     border-bottom: 1px solid var(--border);
                     display: flex;
                     justify-content: space-between;
                     align-items: center;
                  "
               >
                  <div style="flex: 1; text-align: left; font-weight: 600; color: grey;">
  Intra<span style="color: lightblue;">TALKS</span><br>
  <span style="font-size: 10px; color: grey; opacity: 0.7;">
    Powered by <span style="color: lightblue;">Google AI</span>
  </span>
  <br><br>
  <span style="font-size: 11px; opacity: 0.6;">MEMBERS</span>
  <br />
  
</div>


                  <i
                     v-if="user.role==='admin'"
                     class="fas fa-shield-alt"
                     style="color: var(--warning); cursor: pointer"
                     @click="openAdmin"
                  ></i>
               </div>
               <div style="flex: 1; overflow-y: auto; padding: 10px">
                  <div
                     v-for="m in sortedMembers"
                     :key="m.email"
                     class="member-row"
                     style="display: flex; align-items: center; gap: 12px; padding: 8px 12px"
                  >
                     <div class="status-dot" :class="m.isOnline ? 'dot-online' : 'dot-offline'"></div>
                     <div>
                        <span :style="{color: m.role==='admin'?'var(--danger)':'inherit', fontSize:'13px'}"
                           >{{ m.username }}</span
                        >
                        <span style="font-size: 9px; opacity: 0.5; display: block"
                           >{{ m.isOnline ? 'Active' : formatLastActive(m) }}</span
                        >
                     </div>
                  </div>
               </div>
               <div
                  style="
                     padding: 15px;
                     border-top: 1px solid var(--border);
                     display: flex;
                     justify-content: space-between;
                  "
               >
                  <i class="fas fa-user-cog" style="cursor: pointer; opacity: 0.7" @click="openProfile"></i>
                  <i class="fas fa-sign-out-alt" style="cursor: pointer; opacity: 0.7" @click="triggerLogout"></i>
               </div>
            </aside>

            <main>
               <header>
                  <i class="fas fa-bars hamburger-icon" @click="showSidebar = true"></i>
                  <div style="flex: 1"></div>

                  <!-- NEW SUMMARY BUTTON -->
                  <div
                     @click="summarizeMessages"
                     style="
                        cursor: pointer;
                        background: var(--panel);
                        border: 1px solid var(--primary);
                        padding: 5px 12px;
                        border-radius: 15px;
                        font-size: 10px;
                        color: var(--primary);
                     "
                  >
                     <i v-if="isAiLoading" class="fas fa-spinner fa-spin"></i>
                     <span v-else><i class="fas fa-robot"></i></span>
                  </div>
               </header>
               <div class="msg-container" :class="{ loaded: !isInitialLoad }" ref="msgContainer" @scroll="handleScroll">
                  <div v-if="messages.length === 0 && !isInitialLoad" class="watermark">
                     <i class="fas fa-comment-dots" style="font-size: 4rem; margin-bottom: 15px"></i>
                     <p style="font-size: 1.2rem; font-weight: 500">Start a Message</p>
                  </div>

                  <template v-for="(msg, idx) in messages" :key="msg.id">
                     <div v-if="shouldShowDate(idx)" class="date-pill">{{ formatDateHeader(msg.timestamp) }}</div>

                     <div
                        class="msg"
                        :class="msg.senderEmail === user.email ? 'me' : 'other'"
                        :style="getSwipeStyle(msg)"
                        @touchstart="handleTouchStart($event, msg)"
                        @touchmove="handleTouchMove($event)"
                        @touchend="handleTouchEnd($event, msg)"
                     >
                        <span
                           v-if="msg.senderEmail !== user.email"
                           style="font-size: 10px; opacity: 0.5; margin-bottom: 2px"
                           >{{ getLiveUsername(msg.senderEmail, msg.senderName) }}</span
                        >

                        <div class="msg-row">
                           <i
                              class="fas fa-reply swipe-icon"
                              :style="{ opacity: touchTargetId === msg.id && Math.abs(touchDelta) > 40 ? 1 : 0, [msg.senderEmail === user.email ? 'left' : 'right']: '-30px' }"
                           ></i>

                           <div class="bubble">
                              <div
                                 v-if="msg.replyTo"
                                 style="
                                    font-size: 11px;
                                    opacity: 0.6;
                                    border-left: 2px solid var(--primary);
                                    padding-left: 8px;
                                    margin-bottom: 6px;
                                 "
                              >
                                 <b>{{ msg.replyTo.user }}</b>: {{ msg.replyTo.text.substring(0,40) }}...
                              </div>
                              <span v-html="formatMessage(msg.text)"></span>
                              <div
                                 class="status-container"
                                 style="
                                    display: flex;
                                    align-items: center;
                                    justify-content: flex-end;
                                    gap: 4px;
                                    font-size: 10px;
                                    margin-top: 4px;
                                    opacity: 0.7;
                                 "
                              >
                                 <span v-if="msg.isEdited" style="font-size: 8px">(edited)</span>
                                 {{ new Date(msg.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})
                                 }}
                                 <span v-if="msg.senderEmail === user.email">
                                    <i
                                       v-if="String(msg.id).startsWith('temp-')"
                                       class="fas fa-spinner fa-spin"
                                       style="font-size: 8px"
                                    ></i>
                                    <template v-else>
                                       <span v-if="isMsgSeen(msg)" style="color: var(--tick-seen); letter-spacing: -3px"
                                          ><i class="fas fa-check-double"></i
                                       ></span>
                                       <i v-else class="fas fa-check" style="opacity: 0.4"></i>
                                    </template>
                                 </span>
                              </div>
                           </div>

                           <div class="msg-menu-wrap">
                              <div class="dots-btn" @click.stop="openMenu($event, msg)">
                                 <i class="fas fa-ellipsis-v"></i>
                              </div>
                           </div>
                        </div>
                     </div>
                  </template>

                  <div v-if="typingUsers.length" class="typing-indicator">
                     <div class="typing-bubble">
                        <div class="dot" style="animation-delay: 0s"></div>
                        <div class="dot" style="animation-delay: 0.2s"></div>
                        <div class="dot" style="animation-delay: 0.4s"></div>
                     </div>
                     <span>{{ typingUsers.map(u => u.username).join(', ') }} is typing...</span>
                  </div>
               </div>

               <div v-if="showScrollBtn" class="scroll-bottom-btn" @click="jumpToBottom">
                  <i class="fas fa-arrow-down" style="color: var(--primary)"></i>
                  <div v-if="hasNewMessages" class="red-dot"></div>
               </div>

               <footer>
                  <div
                     v-if="editTarget"
                     style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 11px;
                        color: var(--warning);
                        margin-bottom: 8px;
                     "
                  >
                     <span>Editing Message</span
                     ><i class="fas fa-times" @click="cancelEdit" style="cursor: pointer"></i>
                  </div>
                  <div
                     v-if="replyTarget"
                     style="
                        display: flex;
                        justify-content: space-between;
                        font-size: 11px;
                        color: var(--primary);
                        margin-bottom: 8px;
                     "
                  >
                     <span>Replying to {{ replyTarget.senderName }}</span
                     ><i class="fas fa-times" @click="replyTarget=null" style="cursor: pointer"></i>
                  </div>

                  <div class="input-pill">
                     <i
                        class="far fa-smile"
                        @click="showEmoji = !showEmoji"
                        style="cursor: pointer; color: var(--muted)"
                     ></i>
                     <textarea
                        v-model="newMessage"
                        placeholder="Message..."
                        rows="1"
                        @input="autoResize"
                        @keypress.enter.prevent="handleSend"
                        ref="inputArea"
                     ></textarea>
                     <!-- Simple button: No more full-UI locking -->
                     <i
                        class="fas fa-paper-plane"
                        :style="{color: newMessage.trim()?'var(--primary)':'var(--muted)'}"
                        @click="handleSend"
                        style="cursor: pointer"
                     ></i>
                  </div>
                  <emoji-picker
                     v-if="showEmoji"
                     @emoji-click="addEmoji"
                     style="position: absolute; bottom: 85px; left: 16px"
                  ></emoji-picker>
               </footer>

               <teleport to="body">
                  <div v-if="activeMenuId" class="menu-backdrop" @click="activeMenuId = null"></div>
                  <div v-if="activeMenuId" class="menu-dropdown" :style="menuCoords" @click.stop>
                     <template v-for="m in [messages.find(m => m.id === activeMenuId)]">
                        <div class="menu-item" @click="initReply(m); activeMenuId=null">
                           <i class="fas fa-reply"></i> Reply
                        </div>
                        <template v-if="m.senderEmail === user.email && canUnsend(m)">
                           <div class="menu-item" @click="initEdit(m); activeMenuId=null">
                              <i class="fas fa-edit"></i> Edit
                           </div>
                           <div class="menu-item danger" @click="triggerUnsend(m); activeMenuId=null">
                              <i class="fas fa-trash"></i> Delete
                           </div>
                        </template>
                     </template>
                  </div>
               </teleport>
            </main>
         </div>
      </div>

      <script>
         const { createApp } = Vue;
         createApp({
            data() {
               const savedUser = JSON.parse(localStorage.getItem("dt_user"));
               return {
                  user: savedUser || null,
                  isBootstrapping: !!savedUser,
                  isRestoringSession: !!savedUser,
                  viewMode: "login",
                  loading: false,
                  isLoggingIn: false,
                  form: { 
                    email: localStorage.getItem("intra_last_email") || "", 
                    pass: "", 
                    username: "" 
                  },
                  profileForm: { username: "", oldPass: "", newPass: "" },
                  adminUsers: [],
                  messages: [],
                  members: [],
                  activeMenuId: null,
                  menuCoords: { top: "0px", left: "0px" },
                  newMessage: "",
                  showSidebar: false,
                  showEmoji: false,
                  showProfile: false,
                  showAdmin: false,
                  editTarget: null,
                  replyTarget: null,
                  typingState: false,
                  typingTimer: null,
                  isInitialLoad: true,
                  showScrollBtn: false,
                  hasNewMessages: false,
                  lastSummaryTime: 0,
                  cooldownMinutes: 5, 
                  deletedIds: [],
                  pendingMutations: {},
                  touchStartX: 0,
                  touchDelta: 0,
                  touchTargetId: null,
                  outbox: [],
                  isSending: false,
                  isAiLoading: false,
                  aiSummaryText: null,
                  isHtml: false,
                  
                  modal: {
                     show: false,
                     title: "",
                     message: "",
                     type: "info",
                     isConfirm: false,
                     confirmText: "OK",
                     callback: null,
                  },
                  polling: null,
               };
            },
            computed: {
               sortedMembers() {
                  return [...this.members].sort((a, b) => b.isOnline - a.isOnline);
               },
               typingUsers() {
                  return this.members.filter((m) => m.isTyping && m.email !== this.user?.email);
               },
            },
            mounted() {
               if (this.user) this.bootstrapApp();
               document.addEventListener("click", (e) => {
                  if (
                     this.activeMenuId !== null &&
                     !e.target.closest(".dots-btn") &&
                     !e.target.closest(".menu-dropdown")
                  ) {
                     this.activeMenuId = null;
                  }
               });
            },
            watch: {
               typingUsers(newVal) {
                  if (newVal.length > 0) {
                     const container = this.$refs.msgContainer;
                     const isAtBottom = container
                        ? container.scrollHeight - container.scrollTop - container.clientHeight < 10
                        : true;
                     if (isAtBottom) this.$nextTick(() => this.scrollToBottom());
                  }
               },
            },
            methods: {
               summarizeMessages() {
  if (this.isAiLoading) return;

  // --- 5-MINUTE COOLDOWN LOGIC ---
  const now = Date.now();
  const cooldownMs = this.cooldownMinutes * 60 * 1000;
  const timePassed = now - this.lastSummaryTime;

  if (timePassed < cooldownMs) {
     const remainingSeconds = Math.ceil((cooldownMs - timePassed) / 1000);
     const mins = Math.floor(remainingSeconds / 60);
     const secs = remainingSeconds % 60;
     
     // Shows "Please wait 4m 30s"
     this.showMsg(
        "Cooldown Active", 
        `Please wait ${mins}m ${secs}s before generating a new summary for today.`, 
        "warning"
     );
     return;
  }
  // -------------------------------

  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const startOfToday = today.getTime();
  const todaysMessages = this.messages.filter(m => m.timestamp >= startOfToday);

  if (todaysMessages.length === 0) {
     this.showMsg("No Messages", "There are no messages to summarize for today yet.", "primary");
     return;
  }

  this.isAiLoading = true;

  const chatContext = todaysMessages.map((m) => ({
     senderName: m.senderName,
     text: m.text,
  }));

  google.script.run
     .withSuccessHandler((summary) => {
        this.isAiLoading = false;
        
        if (summary === "ALL_KEYS_EXHAUSTED") {
           this.showMsg("Daily Limit Reached", "All AI slots are full. Try again tomorrow.", "danger");
           return;
        }

        // --- IMPORTANT: ONLY update the timer if the AI actually succeeded ---
        this.lastSummaryTime = Date.now();

        // (Continue with your existing logic to format and show the HTML summary)
        let formatted = summary.replace(/\*\*(.*?)\*\*/g, "<b>$1</b>");
        let segments = formatted.split(/\n|\*/).map(s => s.trim()).filter(s => s.length > 2);
        let listItems = segments.map(item => `<li>${item}</li>`).join("");

        const finalHtml = `
            <div class="summary-container">
                <div class="summary-badge">AI SUMMARY (REFRESHES EVERY 5min)</div>
                <ul class="summary-list">${listItems}</ul>
            </div>
        `;
        this.showMsg("Today's Summary", finalHtml, "primary");
     })
     .withFailureHandler(() => {
        this.isAiLoading = false;
        this.showMsg("Error", "Could not connect to AI. Please try again later.", "danger");
     })
     .apiAiSummarize(chatContext);
},
               // Purpose: Handles the first load of the app with strict error catching for fatal boot errors
               async bootstrapApp() {
                  // If we are restoring a session, this is likely already true, but we ensure it here
                  this.isBootstrapping = true;

                  google.script.run
                     .withSuccessHandler((res) => {
                        if (!res || res.success === false) {
                           // Session is invalid or error occurred
                           localStorage.removeItem("dt_user");
                           this.user = null;
                           this.isBootstrapping = false;
                           this.isRestoringSession = false; // Reset this here!
                           this.isLoggingIn = false;
                           this.showMsg("Session Expired", "Please login again.");
                           return;
                        }

                        this.members = res.members;
                        this.messages = res.messages;

                        // Turn off the loading/auth overlay
                        this.isBootstrapping = false;
                        this.isLoggingIn = false;

                        this.$nextTick(() => {
                           const container = this.$refs.msgContainer;
                           if (container) {
                              container.scrollTop = container.scrollHeight;
                              setTimeout(() => {
                                 this.isInitialLoad = false;
                                 this.startSync();
                              }, 100);
                           } else {
                              this.isInitialLoad = false;
                              this.startSync();
                           }
                        });
                     })
                     .withFailureHandler(() => {
                        this.isBootstrapping = false;
                        this.isLoggingIn = false;
                     })
                     .apiSync(this.user.email, true);
               },
               // Purpose: Logic to position the 3-dot context menu correctly on screen
               openMenu(event, msg) {
                  this.activeMenuId = msg.id;
                  const rect = event.currentTarget.getBoundingClientRect();
                  const canMod = msg.senderEmail === this.user.email && this.canUnsend(msg);
                  const itemCount = canMod ? 3 : 1;
                  const itemHeight = window.innerWidth <= 600 ? 60 : 42;
                  const menuH = itemCount * itemHeight;
                  const offset = itemCount === 1 ? 5 : 22;
                  const spaceBelow = window.innerHeight - rect.bottom;
                  let top = spaceBelow < menuH + 50 ? rect.top - menuH - offset : rect.bottom + offset;
                  let left = rect.left;
                  if (left + 160 > window.innerWidth) left = window.innerWidth - 175;
                  this.menuCoords = { top: top + "px", left: left + "px" };
               },

               // Purpose: Retrieves current username from member list for dynamic updates
               getLiveUsername(email, fallbackName) {
                  const member = this.members.find((m) => m.email === email);
                  return member ? member.username : fallbackName;
               },

               // Purpose: Track starting X coordinate for swipe gesture
               handleTouchStart(e, msg) {
                  this.touchStartX = e.touches[0].clientX;
                  this.touchTargetId = msg.id;
                  this.touchDelta = 0;
               },

               // Purpose: Calculate horizontal movement during swipe
               handleTouchMove(e) {
                  this.touchDelta = e.touches[0].clientX - this.touchStartX;
               },

               // Purpose: Finalize swipe and trigger reply if distance met
               handleTouchEnd(e, msg) {
                  if (this.touchDelta > 65 || (this.touchDelta < -65 && msg.senderEmail === this.user.email))
                     this.initReply(msg);
                  this.touchTargetId = null;
                  this.touchDelta = 0;
               },

               // Purpose: Generate CSS transform for smooth swipe UI feedback
               getSwipeStyle(msg) {
                  if (this.touchTargetId === msg.id && Math.abs(this.touchDelta) > 10) {
                     return {
                        transform: `translateX(${Math.max(Math.min(this.touchDelta, 75), -75)}px)`,
                     };
                  }
                  return { transform: "translateX(0px)" };
               },

               // Purpose: Dynamic textarea height adjustment as user types
               autoResize(e) {
                  e.target.style.height = "auto";
                  e.target.style.height = e.target.scrollHeight + "px";
                  this.handleTyping();
               },

               // Purpose: Main gate for sending new or edited messages
               async handleSend() {
                  const sanitizedText = this.newMessage.replace(/[\u200B-\u200D\uFEFF]/g, "").trim();
                  if (!sanitizedText) {
                     this.newMessage = "";
                     return;
                  }

                  // --- INSTANT UI UPDATE ---
                  const textToSubmit = sanitizedText;
                  const tempId = "temp-" + Date.now();

                  // Create the reply object if needed
                  const rp = this.replyTarget
                     ? { user: this.replyTarget.senderName, text: this.replyTarget.text }
                     : null;

                  // Push message to the screen immediately
                  this.messages.push({
                     id: tempId,
                     senderName: this.user.username,
                     senderEmail: this.user.email,
                     text: textToSubmit,
                     replyTo: rp,
                     timestamp: Date.now(),
                  });

                  // Reset the input area immediately so it feels "snappy"
                  this.newMessage = "";
                  this.replyTarget = null;
                  this.editTarget = null;
                  this.showEmoji = false;
                  if (this.$refs.inputArea) this.$refs.inputArea.style.height = "auto";
                  this.scrollToBottom();

                  // --- BACKGROUND PROCESSING ---
                  // We add it to the outbox to be processed in the background
                  this.outbox.push({ tempId, text: textToSubmit, rp });
                  this.processOutbox();
               },

               // Purpose: Optimistic UI message creation and queue addition
               async submitNewMessage(text) {
                  const tempId = "temp-" + Date.now();
                  const rp = this.replyTarget
                     ? { user: this.replyTarget.senderName, text: this.replyTarget.text }
                     : null;
                  this.messages.push({
                     id: tempId,
                     senderName: this.user.username,
                     senderEmail: this.user.email,
                     text,
                     replyTo: rp,
                     timestamp: Date.now(),
                  });
                  this.replyTarget = null;
                  this.scrollToBottom();
                  this.outbox.push({ tempId, text, rp });
                  this.processOutbox();
               },

               // Purpose: Processes the message queue with a retry limit and circuit breaker for failed messages
               // --- AFTER (Use this version) ---
               async processOutbox() {
                  if (this.isSending || this.outbox.length === 0) return;
                  this.isSending = true;

                  while (this.outbox.length > 0) {
                     const item = this.outbox[0];

                     try {
                        // Directly call Send without checking moderation
                        const res = await this.silentCall("apiSendMessage", this.user.email, item.text, item.rp);

                        if (res && res.success) {
                           const f = this.messages.find((m) => m.id === item.tempId);
                           if (f) f.id = res.newId; // Swap temp ID for real ID
                           this.outbox.shift();
                        } else {
                           throw new Error("Send failed");
                        }
                     } catch (e) {
                        console.error("Background processing error:", e);
                        this.outbox.shift(); // Remove failed item to prevent infinite loops
                     }
                  }
                  this.isSending = false;
               },

               // Purpose: Prepare UI to edit an existing message
               initEdit(msg) {
                  this.editTarget = msg;
                  this.newMessage = msg.text;
                  this.$nextTick(() => this.$refs.inputArea.focus());
               },

               // Purpose: Close edit mode without changes
               cancelEdit() {
                  this.editTarget = null;
                  this.newMessage = "";
               },

               // Purpose: Locally apply edit changes and send to server
               async submitEdit(text) {
                  const tid = this.editTarget.id;
                  this.pendingMutations[tid] = text;
                  const idx = this.messages.findIndex((m) => m.id === tid);
                  if (idx !== -1) {
                     this.messages[idx].text = text;
                     this.messages[idx].isEdited = true;
                  }
                  this.cancelEdit();
                  try {
                     await this.silentCall("apiEditMessage", this.user.email, tid, text);
                  } catch (e) {}
               },

               // Purpose: Focus input for replying to a specific user
               initReply(msg) {
                  this.replyTarget = msg;
                  this.$nextTick(() => this.$refs.inputArea.focus());
               },

               // Purpose: Immediate local deletion and remote sync for messages
               triggerUnsend(msg) {
                  this.confirmAction(
                     "Delete Message?",
                     "This action cannot be undone.",
                     "DELETE",
                     "danger",
                     async () => {
                        this.deletedIds.push(msg.id);
                        this.messages = this.messages.filter((m) => m.id !== msg.id);
                        this.silentCall("apiDeleteMessage", this.user.email, msg.id);
                     }
                  );
               },

               // Purpose: Fully reset application state and storage on logout
               triggerLogout() {
                  this.confirmAction("Logout", "Are you sure?", "LOGOUT", "danger", () => {
                     // 1. Stop background syncing
                     clearInterval(this.polling);

                     // 2. Clear local storage
                     localStorage.removeItem("dt_user");

                     // 3. RESET ALL FLAGS (This prevents the "Restoring Session" screen)
                     this.user = null;
                     this.isBootstrapping = false;
                     this.isRestoringSession = false;
                     this.isLoggingIn = false;
                     this.isInitialLoad = true;

                     // 4. Reset UI state
                     this.viewMode = "login";
                     this.messages = [];
                     this.members = [];
                     this.showSidebar = false;
                  });
               },

               // Purpose: Activate the real-time polling interval
               startSync() {
                  this.syncData();
                  this.polling = setInterval(this.syncData, 2500);
               },

               // Purpose: Background data reconciliation with failure-resilient polling logic
               // UPDATE THIS METHOD
               syncData() {
                  if (!this.user || this.loading) return;

                  const oldMsgCount = this.messages.length;

                  google.script.run
                     .withSuccessHandler((res) => {
                        if (!res) return;
                        this.members = res.members;

                        // Get all current temp IDs to avoid showing them twice
                        const currentTempTexts = this.messages
                           .filter((m) => String(m.id).startsWith("temp-"))
                           .map((m) => m.text + m.timestamp);

                        const serverMessages = res.messages
                           .filter((m) => !this.deletedIds.includes(m.id))
                           .map((m) => {
                              // Apply pending local edits if any
                              if (this.pendingMutations[m.id]) {
                                 return { ...m, text: this.pendingMutations[m.id], isEdited: true };
                              }
                              return m;
                           });

                        // Filter out server messages that we already have as "temp" messages
                        // This prevents the "duplicate then remove" glitch
                        const filteredServerMessages = serverMessages.filter((sm) => {
                           const isAlreadyTemp = currentTempTexts.includes(sm.text + sm.timestamp);
                           return !isAlreadyTemp;
                        });

                        const temps = this.messages.filter((m) => String(m.id).startsWith("temp-"));

                        // Re-build message list: Server first, then local pending ones
                        this.messages = [...filteredServerMessages, ...temps];

                        this.$nextTick(() => {
                           const container = this.$refs.msgContainer;
                           if (!container) return;
                           if (this.isInitialLoad) {
                              container.scrollTop = container.scrollHeight;
                              setTimeout(() => {
                                 this.isInitialLoad = false;
                              }, 50);
                           } else if (this.messages.length > oldMsgCount) {
                              const isNearBottom =
                                 container.scrollHeight - container.scrollTop - container.clientHeight < 150;
                              if (isNearBottom) this.scrollToBottom();
                              else this.hasNewMessages = true;
                           }
                        });
                     })
                     .apiSync(this.user.email, false, this.typingState);
               },

               // Purpose: Handles authentication with server-side error message mapping
               async login() {
                  if (!this.form.email || !this.form.pass) {
                     this.showMsg("Missing Info", "Please enter both email and password.", "warning");
                     return;
                  }

                  this.isLoggingIn = true;
                  this.isRestoringSession = false; // <--- Mark this as a fresh login, not a refresh

                  google.script.run
                     .withSuccessHandler((res) => {
                        if (res && res.success) {
                           this.user = res.user;
                           localStorage.setItem("dt_user", JSON.stringify(this.user));
                           localStorage.setItem("intra_last_email", this.form.email);


                           // Proceed to load chat data
                           this.bootstrapApp();
                        } else {
                           this.isLoggingIn = false;
                           this.showMsg("Access Denied", res?.error || "Invalid credentials.", "danger");
                        }
                     })
                     .withFailureHandler(() => {
                        this.isLoggingIn = false;
                        this.showMsg("Login Error", "Server connection failed.", "danger");
                     })
                     .apiLogin(this.form.email, this.form.pass);
               },

               // Purpose: Register new user accounts
               async register() {
                  const res = await this.callServer("apiRegister", this.form.email, this.form.username, this.form.pass);
                  if (res.success) {
                     this.showMsg("Success", "Registered.");
                     this.viewMode = "login";
                  }
               },

               // Purpose: Trigger password recovery email flow
               async sendForgot() {
                  if (!this.form.email) {
                     this.showMsg("Input Required", "Please enter your email address first.", "warning");
                     return;
                  }

                  // We use callServer because it shows the loader while checking the backend
                  const res = await this.callServer("apiForgot", this.form.email);

                  if (res.success) {
                     this.showMsg("Email Sent", res.message, "primary");
                     this.viewMode = "login"; // Go back to login after success
                  } else {
                     // This will display the "Please wait 12 more hours" message from the backend
                     this.showMsg("Request Blocked", res.error, "danger");
                  }
               },

               // Purpose: Fetch user list for the admin interface
               async openAdmin() {
                  const res = await this.callServer("apiAdminGetUsers", this.user.email);
                  if (res.success) {
                     this.adminUsers = res.users;
                     this.showAdmin = true;
                  }
               },

               // Purpose: Execute administrative actions like Approve or Ban
               async adminAction(target, action) {
                  await this.callServer("apiAdminAction", this.user.email, target, action);
                  this.openAdmin();
               },

               // Purpose: Save new profile metadata or credentials
               async updateProfile() {
                  const res = await this.callServer(
                     "apiUpdateProfile",
                     this.user.email,
                     this.profileForm.username,
                     this.profileForm.oldPass,
                     this.profileForm.newPass
                  );
                  if (res.success) {
                     this.user = res.user;
                     this.showProfile = false;
                  }
               },

               // Purpose: Determine if the 'Back to bottom' shortcut button should appear
               handleScroll() {
                  const c = this.$refs.msgContainer;
                  if (!c) return;
                  const isAtBottom = c.scrollHeight - c.scrollTop - c.clientHeight < 50;
                  this.showScrollBtn = !isAtBottom;
                  if (isAtBottom) this.hasNewMessages = false;
                  if (this.activeMenuId) this.activeMenuId = null;
               },

               // Purpose: Programmatic scroll jump with red-dot reset
               jumpToBottom() {
                  this.scrollToBottom();
                  this.hasNewMessages = false;
               },

               // Purpose: Native scrolling logic (Instant or Smooth)
               scrollToBottom(isInstant = false) {
                  this.$nextTick(() => {
                     const c = this.$refs.msgContainer;
                     if (!c) return;

                     if (isInstant) {
                        // Instant snap for when the chat first opens
                        c.scrollTop = c.scrollHeight;
                     } else {
                        // Smooth behavior for when a user sends a message
                        c.scrollTo({
                           top: c.scrollHeight,
                           behavior: "smooth",
                        });
                     }
                  });
               },

               // Purpose: Convert last active timestamp into relative human-readable text
               formatLastActive(m) {
                  if (!m.lastSeen) return "Offline";
                  const diff = Date.now() - m.lastSeen;
                  const min = Math.floor(diff / 60000);
                  if (min < 1) return "Active Just Now";
                  if (min < 60) return `Active ${min}m Ago`;
                  const hrs = Math.floor(min / 60);
                  if (hrs < 24) return `Active ${hrs}h Ago`;
                  return `Active ${Math.floor(hrs / 24)}d Ago`;
               },

               // Purpose: Checks if any member besides sender has a later last-seen than msg timestamp
               isMsgSeen(msg) {
                  return this.members
                     .filter((m) => m.email !== this.user.email)
                     .some((m) => m.lastSeen > msg.timestamp);
               },

               // Purpose: Inject clickable anchor tags into message body URLs
               formatMessage(t) {
                  return t.replace(
                     /(https?:\/\/[^\s]+)/g,
                     '<a href="$1" target="_blank" style="color:var(--primary)">$1</a>'
                  );
               },

               // Purpose: UI logic to grouping messages by date headers
               shouldShowDate(i) {
                  return (
                     i === 0 ||
                     new Date(this.messages[i].timestamp).toDateString() !==
                        new Date(this.messages[i - 1].timestamp).toDateString()
                  );
               },

               // Purpose: Returns "Today" or specific date for headers
               formatDateHeader(ts) {
                  const date = new Date(ts);
                  const today = new Date();
                  const yesterday = new Date();
                  yesterday.setDate(today.getDate() - 1);

                  if (date.toDateString() === today.toDateString()) return "Today";
                  if (date.toDateString() === yesterday.toDateString()) return "Yesterday";

                  return date.toLocaleDateString("en-US", {
                     month: "long",
                     day: "numeric",
                     year: "numeric",
                  });
               },

               // Purpose: Configuration and display of alert modal
               showMsg(title, message, type = "info") {
                  this.modal = { show: true, title, message, type, isConfirm: false };
               },

               // Purpose: Configuration and display of choice modal
               confirmAction(title, message, confirmText, type, callback) {
                  this.modal = { show: true, title, message, type, isConfirm: true, confirmText, callback };
               },

               // Purpose: Logic executed on closing modals
               closeModal(res) {
                  this.modal.show = false;
                  if (res && this.modal.callback) this.modal.callback();
               },

               // Purpose: Manage typing indicator timeout
               // UPDATE THIS METHOD
               handleTyping() {
                  // 1. Immediately set typing to true
                  this.typingState = true;

                  // 2. Clear any existing timer to "reset" the countdown
                  if (this.typingTimer) clearTimeout(this.typingTimer);

                  // 3. Set a timer to flip the status back to false after 3 seconds of inactivity
                  this.typingTimer = setTimeout(() => {
                     this.typingState = false;
                  }, 3000);
               },

               // Purpose: Insert emoji character at cursor/end of text
               addEmoji(e) {
                  this.newMessage += e.detail.unicode;
                  this.showEmoji = false;
               },

               // Purpose: Time-based lock logic for unsend feature
               canUnsend(msg) {
                  return (Date.now() - msg.timestamp) / 1000 < 60;
               },

               // Purpose: Wrapper for GAS server calls that require global loading UI
               async callServer(f, ...a) {
                  this.loading = true;
                  return new Promise((r) => {
                     google.script.run
                        .withSuccessHandler((res) => {
                           this.loading = false;
                           r(res);
                        })
                        .withFailureHandler((err) => {
                           this.loading = false;
                           console.error("Server Error:", err);
                           this.showMsg(
                              "System Error",
                              "Communication with server failed. Please try again.",
                              "danger"
                           );
                           r({ success: false, error: err.message });
                        })
                        [f](...a);
                  });
               },

               // Purpose: Wrapper for GAS server calls that execute silently in background
               async silentCall(f, ...a) {
                  return new Promise((r) => {
                     google.script.run
                        .withSuccessHandler(r)
                        .withFailureHandler((err) => {
                           console.warn(`Silent call to ${f} failed:`, err);
                           r({ success: false, error: err.message });
                        })
                        [f](...a);
                  });
               },

               // Purpose: Setup form state for account settings modal
               openProfile() {
                  this.profileForm = { username: this.user.username, oldPass: "", newPass: "" };
                  this.showProfile = true;
               },
            },
         }).mount("#app");
      </script>
   </body>
</html>
